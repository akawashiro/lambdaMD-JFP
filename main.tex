% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\newif\ifnotanonymous \notanonymoustrue
\newif\iffullversion \fullversiontrue
\documentclass{jfp1}
\bibliographystyle{jfp}

\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{graphicx}
\usepackage{color}
% "amsmath" and "amsthm" package conflicts with the JFP style file. To use
% amsmath, I comment out equation* environment in JFP style file.
% \usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{bcprules, proof}
\usepackage{fancybox}
\usepackage{float}
\usepackage{xparse}
\usepackage{lscape}
\usepackage{xspace}
\usepackage{url}
\usepackage{bcpproof}
\usepackage{multicol}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% This package conflicts with JFP style file.
% \usepackage{cite}
% \usepackage[dvipdfmx]{hyperref}
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\red}[1]{\textcolor{red}{#1 }}
\newcommand{\blue}[1]{\textcolor{blue}{#1 }}

\input{fig-src/symbols.tex}

\newcommand{\rulefbox}[1]{\fbox{\ensuremath{#1}} \hspace{1mm}}

\newcommand{\AI}[1]{\textcolor{red}{[#1 -- AI]}}
\newcommand{\AK}[1]{\textcolor{blue}{[#1 -- AK]}}
\newcommand{\RESUME}{\AK{========== RESUME HERE ==========}}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}

\begin{document}

\title{A Dependently Typed Multi-Stage Calculus}
\author[Akira Kawata, Igarashi Atsushi]{AKIRA KAWATA, ATSUSHI IGARASHI\\
\textit{Kyoto University, Japan}\\
(\textit{email}:\texttt{akira@fos.kuis.kyoto-u.ac.jp}, \texttt{igarashi@kuis.kyoto-u.ac.jp})
}			% Author name in English

\maketitle

\begin{abstract}

% Merits of multi-stage programming

Multi-stage programming is a programming paradigm that enables generation and
evaluation of code at run-time. For instance, MetaOCaml is a well-known
multi-stage programming language supporting quasi-quotation and cross-stage
persistence for the manipulation of code fragments as first-class values
and an evaluation construct for the execution of programs dynamically
generated by code manipulation. A significant merit of multi-stage
programming is the utilization of run-time information during code
generation. For example, we can generate an efficient vector sum function
for arbitrary fixed-length vectors by unrolling loops.

% Problems of multi-stage programming

However, such optimization may cause severe problems because specialized
functions only can be used with restricted arguments. In the case of a
vector addition function, the generated function is specialized for the
given length and must be used with vectors of the correct length.
Otherwise, the function can access outside of vectors because the
loop-unrolled code never checks the boundaries of its input.

% Our solution for the problem

To resolve the above problem, we study a dependently typed extension of a
multi-stage programming language \`a la MetaOCaml. Dependent types bring to
multi-stage programming the enforcement of strong invariants---beyond
simple type safety---on the behavior of dynamically generated code. In the
case of the vector sum function, dependent types restrict the input
arguments to vectors of the correct length. However, extending multi-stage
programming with dependent types is non-trivial because such a type system
must integrate stages of types, which is the number of surrounding
quotations.

% Our contibution

To rigorously study properties of such an extension, we develop \LMD, which is
an extension of typed calculus \LTP proposed by Hanada and Igarashi with
dependent types, and prove its properties, including preservation,
confluence, strong normalization for full reduction, and progress for
staged reduction.  Furthermore, we design algorithmic typing to implement a
type-inference program and prove its equivalence to the original typing. 

\end{abstract}

\tableofcontents

\input{main-src/introduction.tex}

\input{main-src/informal-overview.tex}

\input{main-src/formal-definition.tex}

\input{main-src/properties.tex}

\input{main-src/related-work.tex}

\input{main-src/conclusion.tex}

\input{main-src/acknowledgments.tex}

\bibliography{main}

\end{document}
